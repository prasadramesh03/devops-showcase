// runtime can't be in strict mode because a global variable is assign and maybe created.
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["react-refresh"],{

/***/ "./node_modules/next/dist/compiled/@next/react-refresh-utils/dist/internal/helpers.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/@next/react-refresh-utils/dist/internal/helpers.js ***!
  \********************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\n/**\r\n * MIT License\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n// This file is copied from the Metro JavaScript bundler, with minor tweaks for\r\n// webpack 4 compatibility.\r\n//\r\n// https://github.com/facebook/metro/blob/d6b9685c730d0d63577db40f41369157f28dfa3a/packages/metro/src/lib/polyfills/require.js\r\nconst runtime_1 = __importDefault(__webpack_require__(/*! next/dist/compiled/react-refresh/runtime */ \"./node_modules/next/dist/compiled/react-refresh/runtime.js\"));\r\nfunction isSafeExport(key) {\r\n    return (key === '__esModule' ||\r\n        key === '__N_SSG' ||\r\n        key === '__N_SSP' ||\r\n        // TODO: remove this key from page config instead of allow listing it\r\n        key === 'config');\r\n}\r\nfunction registerExportsForReactRefresh(moduleExports, moduleID) {\r\n    runtime_1.default.register(moduleExports, moduleID + ' %exports%');\r\n    if (moduleExports == null || typeof moduleExports !== 'object') {\r\n        // Exit if we can't iterate over exports.\r\n        // (This is important for legacy environments.)\r\n        return;\r\n    }\r\n    for (var key in moduleExports) {\r\n        if (isSafeExport(key)) {\r\n            continue;\r\n        }\r\n        try {\r\n            var exportValue = moduleExports[key];\r\n        }\r\n        catch (_a) {\r\n            // This might fail due to circular dependencies\r\n            continue;\r\n        }\r\n        var typeID = moduleID + ' %exports% ' + key;\r\n        runtime_1.default.register(exportValue, typeID);\r\n    }\r\n}\r\nfunction getRefreshBoundarySignature(moduleExports) {\r\n    var signature = [];\r\n    signature.push(runtime_1.default.getFamilyByType(moduleExports));\r\n    if (moduleExports == null || typeof moduleExports !== 'object') {\r\n        // Exit if we can't iterate over exports.\r\n        // (This is important for legacy environments.)\r\n        return signature;\r\n    }\r\n    for (var key in moduleExports) {\r\n        if (isSafeExport(key)) {\r\n            continue;\r\n        }\r\n        try {\r\n            var exportValue = moduleExports[key];\r\n        }\r\n        catch (_a) {\r\n            // This might fail due to circular dependencies\r\n            continue;\r\n        }\r\n        signature.push(key);\r\n        signature.push(runtime_1.default.getFamilyByType(exportValue));\r\n    }\r\n    return signature;\r\n}\r\nfunction isReactRefreshBoundary(moduleExports) {\r\n    if (runtime_1.default.isLikelyComponentType(moduleExports)) {\r\n        return true;\r\n    }\r\n    if (moduleExports == null || typeof moduleExports !== 'object') {\r\n        // Exit if we can't iterate over exports.\r\n        return false;\r\n    }\r\n    var hasExports = false;\r\n    var areAllExportsComponents = true;\r\n    for (var key in moduleExports) {\r\n        hasExports = true;\r\n        if (isSafeExport(key)) {\r\n            continue;\r\n        }\r\n        try {\r\n            var exportValue = moduleExports[key];\r\n        }\r\n        catch (_a) {\r\n            // This might fail due to circular dependencies\r\n            return false;\r\n        }\r\n        if (!runtime_1.default.isLikelyComponentType(exportValue)) {\r\n            areAllExportsComponents = false;\r\n        }\r\n    }\r\n    return hasExports && areAllExportsComponents;\r\n}\r\nfunction shouldInvalidateReactRefreshBoundary(prevSignature, nextSignature) {\r\n    if (prevSignature.length !== nextSignature.length) {\r\n        return true;\r\n    }\r\n    for (var i = 0; i < nextSignature.length; i++) {\r\n        if (prevSignature[i] !== nextSignature[i]) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nvar isUpdateScheduled = false;\r\n// This function aggregates updates from multiple modules into a single React Refresh call.\r\nfunction scheduleUpdate() {\r\n    if (isUpdateScheduled) {\r\n        return;\r\n    }\r\n    isUpdateScheduled = true;\r\n    function canApplyUpdate(status) {\r\n        return status === 'idle';\r\n    }\r\n    function applyUpdate() {\r\n        isUpdateScheduled = false;\r\n        try {\r\n            runtime_1.default.performReactRefresh();\r\n        }\r\n        catch (err) {\r\n            console.warn('Warning: Failed to re-render. We will retry on the next Fast Refresh event.\\n' +\r\n                err);\r\n        }\r\n    }\r\n    if (canApplyUpdate(module.hot.status())) {\r\n        // Apply update on the next tick.\r\n        Promise.resolve().then(() => {\r\n            applyUpdate();\r\n        });\r\n        return;\r\n    }\r\n    const statusHandler = (status) => {\r\n        if (canApplyUpdate(status)) {\r\n            module.hot.removeStatusHandler(statusHandler);\r\n            applyUpdate();\r\n        }\r\n    };\r\n    // Apply update once the HMR runtime's status is idle.\r\n    module.hot.addStatusHandler(statusHandler);\r\n}\r\n// Needs to be compatible with IE11\r\nexports[\"default\"] = {\r\n    registerExportsForReactRefresh: registerExportsForReactRefresh,\r\n    isReactRefreshBoundary: isReactRefreshBoundary,\r\n    shouldInvalidateReactRefreshBoundary: shouldInvalidateReactRefreshBoundary,\r\n    getRefreshBoundarySignature: getRefreshBoundarySignature,\r\n    scheduleUpdate: scheduleUpdate,\r\n};\r\n//# sourceMappingURL=helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL0BuZXh0L3JlYWN0LXJlZnJlc2gtdXRpbHMvZGlzdC9pbnRlcm5hbC9oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1CQUFPLENBQUMsNEdBQTBDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxVQUFVO0FBQ2Q7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xccmF2aW5cXERvY3VtZW50c1xcZGV2b3BzLXNob3djYXNlXFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxjb21waWxlZFxcQG5leHRcXHJlYWN0LXJlZnJlc2gtdXRpbHNcXGRpc3RcXGludGVybmFsXFxoZWxwZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKipcclxuICogTUlUIExpY2Vuc2VcclxuICpcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxyXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKlxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxyXG4gKiBTT0ZUV0FSRS5cclxuICovXHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLy8gVGhpcyBmaWxlIGlzIGNvcGllZCBmcm9tIHRoZSBNZXRybyBKYXZhU2NyaXB0IGJ1bmRsZXIsIHdpdGggbWlub3IgdHdlYWtzIGZvclxyXG4vLyB3ZWJwYWNrIDQgY29tcGF0aWJpbGl0eS5cclxuLy9cclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL21ldHJvL2Jsb2IvZDZiOTY4NWM3MzBkMGQ2MzU3N2RiNDBmNDEzNjkxNTdmMjhkZmEzYS9wYWNrYWdlcy9tZXRyby9zcmMvbGliL3BvbHlmaWxscy9yZXF1aXJlLmpzXHJcbmNvbnN0IHJ1bnRpbWVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LXJlZnJlc2gvcnVudGltZVwiKSk7XHJcbmZ1bmN0aW9uIGlzU2FmZUV4cG9ydChrZXkpIHtcclxuICAgIHJldHVybiAoa2V5ID09PSAnX19lc01vZHVsZScgfHxcclxuICAgICAgICBrZXkgPT09ICdfX05fU1NHJyB8fFxyXG4gICAgICAgIGtleSA9PT0gJ19fTl9TU1AnIHx8XHJcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMga2V5IGZyb20gcGFnZSBjb25maWcgaW5zdGVhZCBvZiBhbGxvdyBsaXN0aW5nIGl0XHJcbiAgICAgICAga2V5ID09PSAnY29uZmlnJyk7XHJcbn1cclxuZnVuY3Rpb24gcmVnaXN0ZXJFeHBvcnRzRm9yUmVhY3RSZWZyZXNoKG1vZHVsZUV4cG9ydHMsIG1vZHVsZUlEKSB7XHJcbiAgICBydW50aW1lXzEuZGVmYXVsdC5yZWdpc3Rlcihtb2R1bGVFeHBvcnRzLCBtb2R1bGVJRCArICcgJWV4cG9ydHMlJyk7XHJcbiAgICBpZiAobW9kdWxlRXhwb3J0cyA9PSBudWxsIHx8IHR5cGVvZiBtb2R1bGVFeHBvcnRzICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIC8vIEV4aXQgaWYgd2UgY2FuJ3QgaXRlcmF0ZSBvdmVyIGV4cG9ydHMuXHJcbiAgICAgICAgLy8gKFRoaXMgaXMgaW1wb3J0YW50IGZvciBsZWdhY3kgZW52aXJvbm1lbnRzLilcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gbW9kdWxlRXhwb3J0cykge1xyXG4gICAgICAgIGlmIChpc1NhZmVFeHBvcnQoa2V5KSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIGV4cG9ydFZhbHVlID0gbW9kdWxlRXhwb3J0c1trZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBtaWdodCBmYWlsIGR1ZSB0byBjaXJjdWxhciBkZXBlbmRlbmNpZXNcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0eXBlSUQgPSBtb2R1bGVJRCArICcgJWV4cG9ydHMlICcgKyBrZXk7XHJcbiAgICAgICAgcnVudGltZV8xLmRlZmF1bHQucmVnaXN0ZXIoZXhwb3J0VmFsdWUsIHR5cGVJRCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0UmVmcmVzaEJvdW5kYXJ5U2lnbmF0dXJlKG1vZHVsZUV4cG9ydHMpIHtcclxuICAgIHZhciBzaWduYXR1cmUgPSBbXTtcclxuICAgIHNpZ25hdHVyZS5wdXNoKHJ1bnRpbWVfMS5kZWZhdWx0LmdldEZhbWlseUJ5VHlwZShtb2R1bGVFeHBvcnRzKSk7XHJcbiAgICBpZiAobW9kdWxlRXhwb3J0cyA9PSBudWxsIHx8IHR5cGVvZiBtb2R1bGVFeHBvcnRzICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIC8vIEV4aXQgaWYgd2UgY2FuJ3QgaXRlcmF0ZSBvdmVyIGV4cG9ydHMuXHJcbiAgICAgICAgLy8gKFRoaXMgaXMgaW1wb3J0YW50IGZvciBsZWdhY3kgZW52aXJvbm1lbnRzLilcclxuICAgICAgICByZXR1cm4gc2lnbmF0dXJlO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIga2V5IGluIG1vZHVsZUV4cG9ydHMpIHtcclxuICAgICAgICBpZiAoaXNTYWZlRXhwb3J0KGtleSkpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciBleHBvcnRWYWx1ZSA9IG1vZHVsZUV4cG9ydHNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgbWlnaHQgZmFpbCBkdWUgdG8gY2lyY3VsYXIgZGVwZW5kZW5jaWVzXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzaWduYXR1cmUucHVzaChrZXkpO1xyXG4gICAgICAgIHNpZ25hdHVyZS5wdXNoKHJ1bnRpbWVfMS5kZWZhdWx0LmdldEZhbWlseUJ5VHlwZShleHBvcnRWYWx1ZSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNpZ25hdHVyZTtcclxufVxyXG5mdW5jdGlvbiBpc1JlYWN0UmVmcmVzaEJvdW5kYXJ5KG1vZHVsZUV4cG9ydHMpIHtcclxuICAgIGlmIChydW50aW1lXzEuZGVmYXVsdC5pc0xpa2VseUNvbXBvbmVudFR5cGUobW9kdWxlRXhwb3J0cykpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChtb2R1bGVFeHBvcnRzID09IG51bGwgfHwgdHlwZW9mIG1vZHVsZUV4cG9ydHMgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgLy8gRXhpdCBpZiB3ZSBjYW4ndCBpdGVyYXRlIG92ZXIgZXhwb3J0cy5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB2YXIgaGFzRXhwb3J0cyA9IGZhbHNlO1xyXG4gICAgdmFyIGFyZUFsbEV4cG9ydHNDb21wb25lbnRzID0gdHJ1ZTtcclxuICAgIGZvciAodmFyIGtleSBpbiBtb2R1bGVFeHBvcnRzKSB7XHJcbiAgICAgICAgaGFzRXhwb3J0cyA9IHRydWU7XHJcbiAgICAgICAgaWYgKGlzU2FmZUV4cG9ydChrZXkpKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgZXhwb3J0VmFsdWUgPSBtb2R1bGVFeHBvcnRzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgICAgICAvLyBUaGlzIG1pZ2h0IGZhaWwgZHVlIHRvIGNpcmN1bGFyIGRlcGVuZGVuY2llc1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcnVudGltZV8xLmRlZmF1bHQuaXNMaWtlbHlDb21wb25lbnRUeXBlKGV4cG9ydFZhbHVlKSkge1xyXG4gICAgICAgICAgICBhcmVBbGxFeHBvcnRzQ29tcG9uZW50cyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBoYXNFeHBvcnRzICYmIGFyZUFsbEV4cG9ydHNDb21wb25lbnRzO1xyXG59XHJcbmZ1bmN0aW9uIHNob3VsZEludmFsaWRhdGVSZWFjdFJlZnJlc2hCb3VuZGFyeShwcmV2U2lnbmF0dXJlLCBuZXh0U2lnbmF0dXJlKSB7XHJcbiAgICBpZiAocHJldlNpZ25hdHVyZS5sZW5ndGggIT09IG5leHRTaWduYXR1cmUubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5leHRTaWduYXR1cmUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAocHJldlNpZ25hdHVyZVtpXSAhPT0gbmV4dFNpZ25hdHVyZVtpXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxudmFyIGlzVXBkYXRlU2NoZWR1bGVkID0gZmFsc2U7XHJcbi8vIFRoaXMgZnVuY3Rpb24gYWdncmVnYXRlcyB1cGRhdGVzIGZyb20gbXVsdGlwbGUgbW9kdWxlcyBpbnRvIGEgc2luZ2xlIFJlYWN0IFJlZnJlc2ggY2FsbC5cclxuZnVuY3Rpb24gc2NoZWR1bGVVcGRhdGUoKSB7XHJcbiAgICBpZiAoaXNVcGRhdGVTY2hlZHVsZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpc1VwZGF0ZVNjaGVkdWxlZCA9IHRydWU7XHJcbiAgICBmdW5jdGlvbiBjYW5BcHBseVVwZGF0ZShzdGF0dXMpIHtcclxuICAgICAgICByZXR1cm4gc3RhdHVzID09PSAnaWRsZSc7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhcHBseVVwZGF0ZSgpIHtcclxuICAgICAgICBpc1VwZGF0ZVNjaGVkdWxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJ1bnRpbWVfMS5kZWZhdWx0LnBlcmZvcm1SZWFjdFJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6IEZhaWxlZCB0byByZS1yZW5kZXIuIFdlIHdpbGwgcmV0cnkgb24gdGhlIG5leHQgRmFzdCBSZWZyZXNoIGV2ZW50LlxcbicgK1xyXG4gICAgICAgICAgICAgICAgZXJyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoY2FuQXBwbHlVcGRhdGUobW9kdWxlLmhvdC5zdGF0dXMoKSkpIHtcclxuICAgICAgICAvLyBBcHBseSB1cGRhdGUgb24gdGhlIG5leHQgdGljay5cclxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgYXBwbHlVcGRhdGUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBzdGF0dXNIYW5kbGVyID0gKHN0YXR1cykgPT4ge1xyXG4gICAgICAgIGlmIChjYW5BcHBseVVwZGF0ZShzdGF0dXMpKSB7XHJcbiAgICAgICAgICAgIG1vZHVsZS5ob3QucmVtb3ZlU3RhdHVzSGFuZGxlcihzdGF0dXNIYW5kbGVyKTtcclxuICAgICAgICAgICAgYXBwbHlVcGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQXBwbHkgdXBkYXRlIG9uY2UgdGhlIEhNUiBydW50aW1lJ3Mgc3RhdHVzIGlzIGlkbGUuXHJcbiAgICBtb2R1bGUuaG90LmFkZFN0YXR1c0hhbmRsZXIoc3RhdHVzSGFuZGxlcik7XHJcbn1cclxuLy8gTmVlZHMgdG8gYmUgY29tcGF0aWJsZSB3aXRoIElFMTFcclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gICAgcmVnaXN0ZXJFeHBvcnRzRm9yUmVhY3RSZWZyZXNoOiByZWdpc3RlckV4cG9ydHNGb3JSZWFjdFJlZnJlc2gsXHJcbiAgICBpc1JlYWN0UmVmcmVzaEJvdW5kYXJ5OiBpc1JlYWN0UmVmcmVzaEJvdW5kYXJ5LFxyXG4gICAgc2hvdWxkSW52YWxpZGF0ZVJlYWN0UmVmcmVzaEJvdW5kYXJ5OiBzaG91bGRJbnZhbGlkYXRlUmVhY3RSZWZyZXNoQm91bmRhcnksXHJcbiAgICBnZXRSZWZyZXNoQm91bmRhcnlTaWduYXR1cmU6IGdldFJlZnJlc2hCb3VuZGFyeVNpZ25hdHVyZSxcclxuICAgIHNjaGVkdWxlVXBkYXRlOiBzY2hlZHVsZVVwZGF0ZSxcclxufTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVycy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/@next/react-refresh-utils/dist/internal/helpers.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/@next/react-refresh-utils/dist/runtime.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/@next/react-refresh-utils/dist/runtime.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst runtime_1 = __importDefault(__webpack_require__(/*! next/dist/compiled/react-refresh/runtime */ \"./node_modules/next/dist/compiled/react-refresh/runtime.js\"));\r\nconst helpers_1 = __importDefault(__webpack_require__(/*! ./internal/helpers */ \"./node_modules/next/dist/compiled/@next/react-refresh-utils/dist/internal/helpers.js\"));\r\n// Hook into ReactDOM initialization\r\nruntime_1.default.injectIntoGlobalHook(self);\r\n// Register global helpers\r\nself.$RefreshHelpers$ = helpers_1.default;\r\n// Register a helper for module execution interception\r\nself.$RefreshInterceptModuleExecution$ = function (webpackModuleId) {\r\n    var prevRefreshReg = self.$RefreshReg$;\r\n    var prevRefreshSig = self.$RefreshSig$;\r\n    self.$RefreshReg$ = function (type, id) {\r\n        runtime_1.default.register(type, webpackModuleId + ' ' + id);\r\n    };\r\n    self.$RefreshSig$ = runtime_1.default.createSignatureFunctionForTransform;\r\n    // Modeled after `useEffect` cleanup pattern:\r\n    // https://react.dev/learn/synchronizing-with-effects#step-3-add-cleanup-if-needed\r\n    return function () {\r\n        self.$RefreshReg$ = prevRefreshReg;\r\n        self.$RefreshSig$ = prevRefreshSig;\r\n    };\r\n};\r\n//# sourceMappingURL=runtime.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL0BuZXh0L3JlYWN0LXJlZnJlc2gtdXRpbHMvZGlzdC9ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0NBQWtDLG1CQUFPLENBQUMsNEdBQTBDO0FBQ3BGLGtDQUFrQyxtQkFBTyxDQUFDLGdIQUFvQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHJhdmluXFxEb2N1bWVudHNcXGRldm9wcy1zaG93Y2FzZVxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcY29tcGlsZWRcXEBuZXh0XFxyZWFjdC1yZWZyZXNoLXV0aWxzXFxkaXN0XFxydW50aW1lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IHJ1bnRpbWVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LXJlZnJlc2gvcnVudGltZVwiKSk7XHJcbmNvbnN0IGhlbHBlcnNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9pbnRlcm5hbC9oZWxwZXJzXCIpKTtcclxuLy8gSG9vayBpbnRvIFJlYWN0RE9NIGluaXRpYWxpemF0aW9uXHJcbnJ1bnRpbWVfMS5kZWZhdWx0LmluamVjdEludG9HbG9iYWxIb29rKHNlbGYpO1xyXG4vLyBSZWdpc3RlciBnbG9iYWwgaGVscGVyc1xyXG5zZWxmLiRSZWZyZXNoSGVscGVycyQgPSBoZWxwZXJzXzEuZGVmYXVsdDtcclxuLy8gUmVnaXN0ZXIgYSBoZWxwZXIgZm9yIG1vZHVsZSBleGVjdXRpb24gaW50ZXJjZXB0aW9uXHJcbnNlbGYuJFJlZnJlc2hJbnRlcmNlcHRNb2R1bGVFeGVjdXRpb24kID0gZnVuY3Rpb24gKHdlYnBhY2tNb2R1bGVJZCkge1xyXG4gICAgdmFyIHByZXZSZWZyZXNoUmVnID0gc2VsZi4kUmVmcmVzaFJlZyQ7XHJcbiAgICB2YXIgcHJldlJlZnJlc2hTaWcgPSBzZWxmLiRSZWZyZXNoU2lnJDtcclxuICAgIHNlbGYuJFJlZnJlc2hSZWckID0gZnVuY3Rpb24gKHR5cGUsIGlkKSB7XHJcbiAgICAgICAgcnVudGltZV8xLmRlZmF1bHQucmVnaXN0ZXIodHlwZSwgd2VicGFja01vZHVsZUlkICsgJyAnICsgaWQpO1xyXG4gICAgfTtcclxuICAgIHNlbGYuJFJlZnJlc2hTaWckID0gcnVudGltZV8xLmRlZmF1bHQuY3JlYXRlU2lnbmF0dXJlRnVuY3Rpb25Gb3JUcmFuc2Zvcm07XHJcbiAgICAvLyBNb2RlbGVkIGFmdGVyIGB1c2VFZmZlY3RgIGNsZWFudXAgcGF0dGVybjpcclxuICAgIC8vIGh0dHBzOi8vcmVhY3QuZGV2L2xlYXJuL3N5bmNocm9uaXppbmctd2l0aC1lZmZlY3RzI3N0ZXAtMy1hZGQtY2xlYW51cC1pZi1uZWVkZWRcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi4kUmVmcmVzaFJlZyQgPSBwcmV2UmVmcmVzaFJlZztcclxuICAgICAgICBzZWxmLiRSZWZyZXNoU2lnJCA9IHByZXZSZWZyZXNoU2lnO1xyXG4gICAgfTtcclxufTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnVudGltZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/@next/react-refresh-utils/dist/runtime.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/react-refresh/cjs/react-refresh-runtime.development.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-refresh/cjs/react-refresh-runtime.development.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\r\n * @license React\r\n * react-refresh-runtime.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n\r\n\r\nif (true) {\r\n  (function() {\r\n'use strict';\r\n\r\n// ATTENTION\r\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\r\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\r\n\r\nvar PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // We never remove these associations.\r\n// It's OK to reference families, but use WeakMap/Set for types.\r\n\r\nvar allFamiliesByID = new Map();\r\nvar allFamiliesByType = new PossiblyWeakMap();\r\nvar allSignaturesByType = new PossiblyWeakMap(); // This WeakMap is read by React, so we only put families\r\n// that have actually been edited here. This keeps checks fast.\r\n// $FlowIssue\r\n\r\nvar updatedFamiliesByType = new PossiblyWeakMap(); // This is cleared on every performReactRefresh() call.\r\n// It is an array of [Family, NextType] tuples.\r\n\r\nvar pendingUpdates = []; // This is injected by the renderer via DevTools global hook.\r\n\r\nvar helpersByRendererID = new Map();\r\nvar helpersByRoot = new Map(); // We keep track of mounted roots so we can schedule updates.\r\n\r\nvar mountedRoots = new Set(); // If a root captures an error, we remember it so we can retry on edit.\r\n\r\nvar failedRoots = new Set(); // In environments that support WeakMap, we also remember the last element for every root.\r\n// It needs to be weak because we do this even for roots that failed to mount.\r\n// If there is no WeakMap, we won't attempt to do retrying.\r\n// $FlowIssue\r\n\r\nvar rootElements = // $FlowIssue\r\ntypeof WeakMap === 'function' ? new WeakMap() : null;\r\nvar isPerformingRefresh = false;\r\n\r\nfunction computeFullKey(signature) {\r\n  if (signature.fullKey !== null) {\r\n    return signature.fullKey;\r\n  }\r\n\r\n  var fullKey = signature.ownKey;\r\n  var hooks;\r\n\r\n  try {\r\n    hooks = signature.getCustomHooks();\r\n  } catch (err) {\r\n    // This can happen in an edge case, e.g. if expression like Foo.useSomething\r\n    // depends on Foo which is lazily initialized during rendering.\r\n    // In that case just assume we'll have to remount.\r\n    signature.forceReset = true;\r\n    signature.fullKey = fullKey;\r\n    return fullKey;\r\n  }\r\n\r\n  for (var i = 0; i < hooks.length; i++) {\r\n    var hook = hooks[i];\r\n\r\n    if (typeof hook !== 'function') {\r\n      // Something's wrong. Assume we need to remount.\r\n      signature.forceReset = true;\r\n      signature.fullKey = fullKey;\r\n      return fullKey;\r\n    }\r\n\r\n    var nestedHookSignature = allSignaturesByType.get(hook);\r\n\r\n    if (nestedHookSignature === undefined) {\r\n      // No signature means Hook wasn't in the source code, e.g. in a library.\r\n      // We'll skip it because we can assume it won't change during this session.\r\n      continue;\r\n    }\r\n\r\n    var nestedHookKey = computeFullKey(nestedHookSignature);\r\n\r\n    if (nestedHookSignature.forceReset) {\r\n      signature.forceReset = true;\r\n    }\r\n\r\n    fullKey += '\\n---\\n' + nestedHookKey;\r\n  }\r\n\r\n  signature.fullKey = fullKey;\r\n  return fullKey;\r\n}\r\n\r\nfunction haveEqualSignatures(prevType, nextType) {\r\n  var prevSignature = allSignaturesByType.get(prevType);\r\n  var nextSignature = allSignaturesByType.get(nextType);\r\n\r\n  if (prevSignature === undefined && nextSignature === undefined) {\r\n    return true;\r\n  }\r\n\r\n  if (prevSignature === undefined || nextSignature === undefined) {\r\n    return false;\r\n  }\r\n\r\n  if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {\r\n    return false;\r\n  }\r\n\r\n  if (nextSignature.forceReset) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction isReactClass(type) {\r\n  return type.prototype && type.prototype.isReactComponent;\r\n}\r\n\r\nfunction canPreserveStateBetween(prevType, nextType) {\r\n  if (isReactClass(prevType) || isReactClass(nextType)) {\r\n    return false;\r\n  }\r\n\r\n  if (haveEqualSignatures(prevType, nextType)) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction resolveFamily(type) {\r\n  // Only check updated types to keep lookups fast.\r\n  return updatedFamiliesByType.get(type);\r\n} // If we didn't care about IE11, we could use new Map/Set(iterable).\r\n\r\n\r\nfunction cloneMap(map) {\r\n  var clone = new Map();\r\n  map.forEach(function (value, key) {\r\n    clone.set(key, value);\r\n  });\r\n  return clone;\r\n}\r\n\r\nfunction cloneSet(set) {\r\n  var clone = new Set();\r\n  set.forEach(function (value) {\r\n    clone.add(value);\r\n  });\r\n  return clone;\r\n} // This is a safety mechanism to protect against rogue getters and Proxies.\r\n\r\n\r\nfunction getProperty(object, property) {\r\n  try {\r\n    return object[property];\r\n  } catch (err) {\r\n    // Intentionally ignore.\r\n    return undefined;\r\n  }\r\n}\r\n\r\nfunction performReactRefresh() {\r\n\r\n  if (pendingUpdates.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  if (isPerformingRefresh) {\r\n    return null;\r\n  }\r\n\r\n  isPerformingRefresh = true;\r\n\r\n  try {\r\n    var staleFamilies = new Set();\r\n    var updatedFamilies = new Set();\r\n    var updates = pendingUpdates;\r\n    pendingUpdates = [];\r\n    updates.forEach(function (_ref) {\r\n      var family = _ref[0],\r\n          nextType = _ref[1];\r\n      // Now that we got a real edit, we can create associations\r\n      // that will be read by the React reconciler.\r\n      var prevType = family.current;\r\n      updatedFamiliesByType.set(prevType, family);\r\n      updatedFamiliesByType.set(nextType, family);\r\n      family.current = nextType; // Determine whether this should be a re-render or a re-mount.\r\n\r\n      if (canPreserveStateBetween(prevType, nextType)) {\r\n        updatedFamilies.add(family);\r\n      } else {\r\n        staleFamilies.add(family);\r\n      }\r\n    }); // TODO: rename these fields to something more meaningful.\r\n\r\n    var update = {\r\n      updatedFamilies: updatedFamilies,\r\n      // Families that will re-render preserving state\r\n      staleFamilies: staleFamilies // Families that will be remounted\r\n\r\n    };\r\n    helpersByRendererID.forEach(function (helpers) {\r\n      // Even if there are no roots, set the handler on first update.\r\n      // This ensures that if *new* roots are mounted, they'll use the resolve handler.\r\n      helpers.setRefreshHandler(resolveFamily);\r\n    });\r\n    var didError = false;\r\n    var firstError = null; // We snapshot maps and sets that are mutated during commits.\r\n    // If we don't do this, there is a risk they will be mutated while\r\n    // we iterate over them. For example, trying to recover a failed root\r\n    // may cause another root to be added to the failed list -- an infinite loop.\r\n\r\n    var failedRootsSnapshot = cloneSet(failedRoots);\r\n    var mountedRootsSnapshot = cloneSet(mountedRoots);\r\n    var helpersByRootSnapshot = cloneMap(helpersByRoot);\r\n    failedRootsSnapshot.forEach(function (root) {\r\n      var helpers = helpersByRootSnapshot.get(root);\r\n\r\n      if (helpers === undefined) {\r\n        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\r\n      }\r\n\r\n      if (!failedRoots.has(root)) {// No longer failed.\r\n      }\r\n\r\n      if (rootElements === null) {\r\n        return;\r\n      }\r\n\r\n      if (!rootElements.has(root)) {\r\n        return;\r\n      }\r\n\r\n      var element = rootElements.get(root);\r\n\r\n      try {\r\n        helpers.scheduleRoot(root, element);\r\n      } catch (err) {\r\n        if (!didError) {\r\n          didError = true;\r\n          firstError = err;\r\n        } // Keep trying other roots.\r\n\r\n      }\r\n    });\r\n    mountedRootsSnapshot.forEach(function (root) {\r\n      var helpers = helpersByRootSnapshot.get(root);\r\n\r\n      if (helpers === undefined) {\r\n        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\r\n      }\r\n\r\n      if (!mountedRoots.has(root)) {// No longer mounted.\r\n      }\r\n\r\n      try {\r\n        helpers.scheduleRefresh(root, update);\r\n      } catch (err) {\r\n        if (!didError) {\r\n          didError = true;\r\n          firstError = err;\r\n        } // Keep trying other roots.\r\n\r\n      }\r\n    });\r\n\r\n    if (didError) {\r\n      throw firstError;\r\n    }\r\n\r\n    return update;\r\n  } finally {\r\n    isPerformingRefresh = false;\r\n  }\r\n}\r\nfunction register(type, id) {\r\n  {\r\n    if (type === null) {\r\n      return;\r\n    }\r\n\r\n    if (typeof type !== 'function' && typeof type !== 'object') {\r\n      return;\r\n    } // This can happen in an edge case, e.g. if we register\r\n    // return value of a HOC but it returns a cached component.\r\n    // Ignore anything but the first registration for each type.\r\n\r\n\r\n    if (allFamiliesByType.has(type)) {\r\n      return;\r\n    } // Create family or remember to update it.\r\n    // None of this bookkeeping affects reconciliation\r\n    // until the first performReactRefresh() call above.\r\n\r\n\r\n    var family = allFamiliesByID.get(id);\r\n\r\n    if (family === undefined) {\r\n      family = {\r\n        current: type\r\n      };\r\n      allFamiliesByID.set(id, family);\r\n    } else {\r\n      pendingUpdates.push([family, type]);\r\n    }\r\n\r\n    allFamiliesByType.set(type, family); // Visit inner types because we might not have registered them.\r\n\r\n    if (typeof type === 'object' && type !== null) {\r\n      switch (getProperty(type, '$$typeof')) {\r\n        case REACT_FORWARD_REF_TYPE:\r\n          register(type.render, id + '$render');\r\n          break;\r\n\r\n        case REACT_MEMO_TYPE:\r\n          register(type.type, id + '$type');\r\n          break;\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction setSignature(type, key) {\r\n  var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n  var getCustomHooks = arguments.length > 3 ? arguments[3] : undefined;\r\n\r\n  {\r\n    if (!allSignaturesByType.has(type)) {\r\n      allSignaturesByType.set(type, {\r\n        forceReset: forceReset,\r\n        ownKey: key,\r\n        fullKey: null,\r\n        getCustomHooks: getCustomHooks || function () {\r\n          return [];\r\n        }\r\n      });\r\n    } // Visit inner types because we might not have signed them.\r\n\r\n\r\n    if (typeof type === 'object' && type !== null) {\r\n      switch (getProperty(type, '$$typeof')) {\r\n        case REACT_FORWARD_REF_TYPE:\r\n          setSignature(type.render, key, forceReset, getCustomHooks);\r\n          break;\r\n\r\n        case REACT_MEMO_TYPE:\r\n          setSignature(type.type, key, forceReset, getCustomHooks);\r\n          break;\r\n      }\r\n    }\r\n  }\r\n} // This is lazily called during first render for a type.\r\n// It captures Hook list at that time so inline requires don't break comparisons.\r\n\r\nfunction collectCustomHooksForSignature(type) {\r\n  {\r\n    var signature = allSignaturesByType.get(type);\r\n\r\n    if (signature !== undefined) {\r\n      computeFullKey(signature);\r\n    }\r\n  }\r\n}\r\nfunction getFamilyByID(id) {\r\n  {\r\n    return allFamiliesByID.get(id);\r\n  }\r\n}\r\nfunction getFamilyByType(type) {\r\n  {\r\n    return allFamiliesByType.get(type);\r\n  }\r\n}\r\nfunction findAffectedHostInstances(families) {\r\n  {\r\n    var affectedInstances = new Set();\r\n    mountedRoots.forEach(function (root) {\r\n      var helpers = helpersByRoot.get(root);\r\n\r\n      if (helpers === undefined) {\r\n        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\r\n      }\r\n\r\n      var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);\r\n      instancesForRoot.forEach(function (inst) {\r\n        affectedInstances.add(inst);\r\n      });\r\n    });\r\n    return affectedInstances;\r\n  }\r\n}\r\nfunction injectIntoGlobalHook(globalObject) {\r\n  {\r\n    // For React Native, the global hook will be set up by require('react-devtools-core').\r\n    // That code will run before us. So we need to monkeypatch functions on existing hook.\r\n    // For React Web, the global hook will be set up by the extension.\r\n    // This will also run before us.\r\n    var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;\r\n\r\n    if (hook === undefined) {\r\n      // However, if there is no DevTools extension, we'll need to set up the global hook ourselves.\r\n      // Note that in this case it's important that renderer code runs *after* this method call.\r\n      // Otherwise, the renderer will think that there is no global hook, and won't do the injection.\r\n      var nextID = 0;\r\n      globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {\r\n        renderers: new Map(),\r\n        supportsFiber: true,\r\n        inject: function (injected) {\r\n          return nextID++;\r\n        },\r\n        onScheduleFiberRoot: function (id, root, children) {},\r\n        onCommitFiberRoot: function (id, root, maybePriorityLevel, didError) {},\r\n        onCommitFiberUnmount: function () {}\r\n      };\r\n    }\r\n\r\n    if (hook.isDisabled) {\r\n      // This isn't a real property on the hook, but it can be set to opt out\r\n      // of DevTools integration and associated warnings and logs.\r\n      // Using console['warn'] to evade Babel and ESLint\r\n      console['warn']('Something has shimmed the React DevTools global hook (__REACT_DEVTOOLS_GLOBAL_HOOK__). ' + 'Fast Refresh is not compatible with this shim and will be disabled.');\r\n      return;\r\n    } // Here, we just want to get a reference to scheduleRefresh.\r\n\r\n\r\n    var oldInject = hook.inject;\r\n\r\n    hook.inject = function (injected) {\r\n      var id = oldInject.apply(this, arguments);\r\n\r\n      if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {\r\n        // This version supports React Refresh.\r\n        helpersByRendererID.set(id, injected);\r\n      }\r\n\r\n      return id;\r\n    }; // Do the same for any already injected roots.\r\n    // This is useful if ReactDOM has already been initialized.\r\n    // https://github.com/facebook/react/issues/17626\r\n\r\n\r\n    hook.renderers.forEach(function (injected, id) {\r\n      if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {\r\n        // This version supports React Refresh.\r\n        helpersByRendererID.set(id, injected);\r\n      }\r\n    }); // We also want to track currently mounted roots.\r\n\r\n    var oldOnCommitFiberRoot = hook.onCommitFiberRoot;\r\n\r\n    var oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || function () {};\r\n\r\n    hook.onScheduleFiberRoot = function (id, root, children) {\r\n      if (!isPerformingRefresh) {\r\n        // If it was intentionally scheduled, don't attempt to restore.\r\n        // This includes intentionally scheduled unmounts.\r\n        failedRoots.delete(root);\r\n\r\n        if (rootElements !== null) {\r\n          rootElements.set(root, children);\r\n        }\r\n      }\r\n\r\n      return oldOnScheduleFiberRoot.apply(this, arguments);\r\n    };\r\n\r\n    hook.onCommitFiberRoot = function (id, root, maybePriorityLevel, didError) {\r\n      var helpers = helpersByRendererID.get(id);\r\n\r\n      if (helpers !== undefined) {\r\n        helpersByRoot.set(root, helpers);\r\n        var current = root.current;\r\n        var alternate = current.alternate; // We need to determine whether this root has just (un)mounted.\r\n        // This logic is copy-pasted from similar logic in the DevTools backend.\r\n        // If this breaks with some refactoring, you'll want to update DevTools too.\r\n\r\n        if (alternate !== null) {\r\n          var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null && mountedRoots.has(root);\r\n          var isMounted = current.memoizedState != null && current.memoizedState.element != null;\r\n\r\n          if (!wasMounted && isMounted) {\r\n            // Mount a new root.\r\n            mountedRoots.add(root);\r\n            failedRoots.delete(root);\r\n          } else if (wasMounted && isMounted) ; else if (wasMounted && !isMounted) {\r\n            // Unmount an existing root.\r\n            mountedRoots.delete(root);\r\n\r\n            if (didError) {\r\n              // We'll remount it on future edits.\r\n              failedRoots.add(root);\r\n            } else {\r\n              helpersByRoot.delete(root);\r\n            }\r\n          } else if (!wasMounted && !isMounted) {\r\n            if (didError) {\r\n              // We'll remount it on future edits.\r\n              failedRoots.add(root);\r\n            }\r\n          }\r\n        } else {\r\n          // Mount a new root.\r\n          mountedRoots.add(root);\r\n        }\r\n      } // Always call the decorated DevTools hook.\r\n\r\n\r\n      return oldOnCommitFiberRoot.apply(this, arguments);\r\n    };\r\n  }\r\n}\r\nfunction hasUnrecoverableErrors() {\r\n  // TODO: delete this after removing dependency in RN.\r\n  return false;\r\n} // Exposed for testing.\r\n\r\nfunction _getMountedRootCount() {\r\n  {\r\n    return mountedRoots.size;\r\n  }\r\n} // This is a wrapper over more primitive functions for setting signature.\r\n// Signatures let us decide whether the Hook order has changed on refresh.\r\n//\r\n// This function is intended to be used as a transform target, e.g.:\r\n// var _s = createSignatureFunctionForTransform()\r\n//\r\n// function Hello() {\r\n//   const [foo, setFoo] = useState(0);\r\n//   const value = useCustomHook();\r\n//   _s(); /* Call without arguments triggers collecting the custom Hook list.\r\n//          * This doesn't happen during the module evaluation because we\r\n//          * don't want to change the module order with inline requires.\r\n//          * Next calls are noops. */\r\n//   return <h1>Hi</h1>;\r\n// }\r\n//\r\n// /* Call with arguments attaches the signature to the type: */\r\n// _s(\r\n//   Hello,\r\n//   'useState{[foo, setFoo]}(0)',\r\n//   () => [useCustomHook], /* Lazy to avoid triggering inline requires */\r\n// );\r\n\r\nfunction createSignatureFunctionForTransform() {\r\n  {\r\n    var savedType;\r\n    var hasCustomHooks;\r\n    var didCollectHooks = false;\r\n    return function (type, key, forceReset, getCustomHooks) {\r\n      if (typeof key === 'string') {\r\n        // We're in the initial phase that associates signatures\r\n        // with the functions. Note this may be called multiple times\r\n        // in HOC chains like _s(hoc1(_s(hoc2(_s(actualFunction))))).\r\n        if (!savedType) {\r\n          // We're in the innermost call, so this is the actual type.\r\n          savedType = type;\r\n          hasCustomHooks = typeof getCustomHooks === 'function';\r\n        } // Set the signature for all types (even wrappers!) in case\r\n        // they have no signatures of their own. This is to prevent\r\n        // problems like https://github.com/facebook/react/issues/20417.\r\n\r\n\r\n        if (type != null && (typeof type === 'function' || typeof type === 'object')) {\r\n          setSignature(type, key, forceReset, getCustomHooks);\r\n        }\r\n\r\n        return type;\r\n      } else {\r\n        // We're in the _s() call without arguments, which means\r\n        // this is the time to collect custom Hook signatures.\r\n        // Only do this once. This path is hot and runs *inside* every render!\r\n        if (!didCollectHooks && hasCustomHooks) {\r\n          didCollectHooks = true;\r\n          collectCustomHooksForSignature(savedType);\r\n        }\r\n      }\r\n    };\r\n  }\r\n}\r\nfunction isLikelyComponentType(type) {\r\n  {\r\n    switch (typeof type) {\r\n      case 'function':\r\n        {\r\n          // First, deal with classes.\r\n          if (type.prototype != null) {\r\n            if (type.prototype.isReactComponent) {\r\n              // React class.\r\n              return true;\r\n            }\r\n\r\n            var ownNames = Object.getOwnPropertyNames(type.prototype);\r\n\r\n            if (ownNames.length > 1 || ownNames[0] !== 'constructor') {\r\n              // This looks like a class.\r\n              return false;\r\n            } // eslint-disable-next-line no-proto\r\n\r\n\r\n            if (type.prototype.__proto__ !== Object.prototype) {\r\n              // It has a superclass.\r\n              return false;\r\n            } // Pass through.\r\n            // This looks like a regular function with empty prototype.\r\n\r\n          } // For plain functions and arrows, use name as a heuristic.\r\n\r\n\r\n          var name = type.name || type.displayName;\r\n          return typeof name === 'string' && /^[A-Z]/.test(name);\r\n        }\r\n\r\n      case 'object':\r\n        {\r\n          if (type != null) {\r\n            switch (getProperty(type, '$$typeof')) {\r\n              case REACT_FORWARD_REF_TYPE:\r\n              case REACT_MEMO_TYPE:\r\n                // Definitely React components.\r\n                return true;\r\n\r\n              default:\r\n                return false;\r\n            }\r\n          }\r\n\r\n          return false;\r\n        }\r\n\r\n      default:\r\n        {\r\n          return false;\r\n        }\r\n    }\r\n  }\r\n}\r\n\r\nexports._getMountedRootCount = _getMountedRootCount;\r\nexports.collectCustomHooksForSignature = collectCustomHooksForSignature;\r\nexports.createSignatureFunctionForTransform = createSignatureFunctionForTransform;\r\nexports.findAffectedHostInstances = findAffectedHostInstances;\r\nexports.getFamilyByID = getFamilyByID;\r\nexports.getFamilyByType = getFamilyByType;\r\nexports.hasUnrecoverableErrors = hasUnrecoverableErrors;\r\nexports.injectIntoGlobalHook = injectIntoGlobalHook;\r\nexports.isLikelyComponentType = isLikelyComponentType;\r\nexports.performReactRefresh = performReactRefresh;\r\nexports.register = register;\r\nexports.setSignature = setSignature;\r\n  })();\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LXJlZnJlc2gvY2pzL3JlYWN0LXJlZnJlc2gtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2I7QUFDQSxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLLEdBQUc7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNkRBQTZEO0FBQzdELCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLHNDQUFzQztBQUN0QywyQ0FBMkM7QUFDM0MsaUNBQWlDO0FBQ2pDLHFCQUFxQjtBQUNyQix1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDRCQUE0QjtBQUM1Qiw2QkFBNkI7QUFDN0IsMkJBQTJCO0FBQzNCLGdCQUFnQjtBQUNoQixvQkFBb0I7QUFDcEIsR0FBRztBQUNIIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHJhdmluXFxEb2N1bWVudHNcXGRldm9wcy1zaG93Y2FzZVxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcY29tcGlsZWRcXHJlYWN0LXJlZnJlc2hcXGNqc1xccmVhY3QtcmVmcmVzaC1ydW50aW1lLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAbGljZW5zZSBSZWFjdFxyXG4gKiByZWFjdC1yZWZyZXNoLXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcclxuICpcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gIChmdW5jdGlvbigpIHtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLy8gQVRURU5USU9OXHJcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcclxudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcclxuXHJcbnZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7IC8vIFdlIG5ldmVyIHJlbW92ZSB0aGVzZSBhc3NvY2lhdGlvbnMuXHJcbi8vIEl0J3MgT0sgdG8gcmVmZXJlbmNlIGZhbWlsaWVzLCBidXQgdXNlIFdlYWtNYXAvU2V0IGZvciB0eXBlcy5cclxuXHJcbnZhciBhbGxGYW1pbGllc0J5SUQgPSBuZXcgTWFwKCk7XHJcbnZhciBhbGxGYW1pbGllc0J5VHlwZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcclxudmFyIGFsbFNpZ25hdHVyZXNCeVR5cGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7IC8vIFRoaXMgV2Vha01hcCBpcyByZWFkIGJ5IFJlYWN0LCBzbyB3ZSBvbmx5IHB1dCBmYW1pbGllc1xyXG4vLyB0aGF0IGhhdmUgYWN0dWFsbHkgYmVlbiBlZGl0ZWQgaGVyZS4gVGhpcyBrZWVwcyBjaGVja3MgZmFzdC5cclxuLy8gJEZsb3dJc3N1ZVxyXG5cclxudmFyIHVwZGF0ZWRGYW1pbGllc0J5VHlwZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTsgLy8gVGhpcyBpcyBjbGVhcmVkIG9uIGV2ZXJ5IHBlcmZvcm1SZWFjdFJlZnJlc2goKSBjYWxsLlxyXG4vLyBJdCBpcyBhbiBhcnJheSBvZiBbRmFtaWx5LCBOZXh0VHlwZV0gdHVwbGVzLlxyXG5cclxudmFyIHBlbmRpbmdVcGRhdGVzID0gW107IC8vIFRoaXMgaXMgaW5qZWN0ZWQgYnkgdGhlIHJlbmRlcmVyIHZpYSBEZXZUb29scyBnbG9iYWwgaG9vay5cclxuXHJcbnZhciBoZWxwZXJzQnlSZW5kZXJlcklEID0gbmV3IE1hcCgpO1xyXG52YXIgaGVscGVyc0J5Um9vdCA9IG5ldyBNYXAoKTsgLy8gV2Uga2VlcCB0cmFjayBvZiBtb3VudGVkIHJvb3RzIHNvIHdlIGNhbiBzY2hlZHVsZSB1cGRhdGVzLlxyXG5cclxudmFyIG1vdW50ZWRSb290cyA9IG5ldyBTZXQoKTsgLy8gSWYgYSByb290IGNhcHR1cmVzIGFuIGVycm9yLCB3ZSByZW1lbWJlciBpdCBzbyB3ZSBjYW4gcmV0cnkgb24gZWRpdC5cclxuXHJcbnZhciBmYWlsZWRSb290cyA9IG5ldyBTZXQoKTsgLy8gSW4gZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBXZWFrTWFwLCB3ZSBhbHNvIHJlbWVtYmVyIHRoZSBsYXN0IGVsZW1lbnQgZm9yIGV2ZXJ5IHJvb3QuXHJcbi8vIEl0IG5lZWRzIHRvIGJlIHdlYWsgYmVjYXVzZSB3ZSBkbyB0aGlzIGV2ZW4gZm9yIHJvb3RzIHRoYXQgZmFpbGVkIHRvIG1vdW50LlxyXG4vLyBJZiB0aGVyZSBpcyBubyBXZWFrTWFwLCB3ZSB3b24ndCBhdHRlbXB0IHRvIGRvIHJldHJ5aW5nLlxyXG4vLyAkRmxvd0lzc3VlXHJcblxyXG52YXIgcm9vdEVsZW1lbnRzID0gLy8gJEZsb3dJc3N1ZVxyXG50eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBXZWFrTWFwKCkgOiBudWxsO1xyXG52YXIgaXNQZXJmb3JtaW5nUmVmcmVzaCA9IGZhbHNlO1xyXG5cclxuZnVuY3Rpb24gY29tcHV0ZUZ1bGxLZXkoc2lnbmF0dXJlKSB7XHJcbiAgaWYgKHNpZ25hdHVyZS5mdWxsS2V5ICE9PSBudWxsKSB7XHJcbiAgICByZXR1cm4gc2lnbmF0dXJlLmZ1bGxLZXk7XHJcbiAgfVxyXG5cclxuICB2YXIgZnVsbEtleSA9IHNpZ25hdHVyZS5vd25LZXk7XHJcbiAgdmFyIGhvb2tzO1xyXG5cclxuICB0cnkge1xyXG4gICAgaG9va3MgPSBzaWduYXR1cmUuZ2V0Q3VzdG9tSG9va3MoKTtcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpbiBhbiBlZGdlIGNhc2UsIGUuZy4gaWYgZXhwcmVzc2lvbiBsaWtlIEZvby51c2VTb21ldGhpbmdcclxuICAgIC8vIGRlcGVuZHMgb24gRm9vIHdoaWNoIGlzIGxhemlseSBpbml0aWFsaXplZCBkdXJpbmcgcmVuZGVyaW5nLlxyXG4gICAgLy8gSW4gdGhhdCBjYXNlIGp1c3QgYXNzdW1lIHdlJ2xsIGhhdmUgdG8gcmVtb3VudC5cclxuICAgIHNpZ25hdHVyZS5mb3JjZVJlc2V0ID0gdHJ1ZTtcclxuICAgIHNpZ25hdHVyZS5mdWxsS2V5ID0gZnVsbEtleTtcclxuICAgIHJldHVybiBmdWxsS2V5O1xyXG4gIH1cclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIGhvb2sgPSBob29rc1tpXTtcclxuXHJcbiAgICBpZiAodHlwZW9mIGhvb2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgLy8gU29tZXRoaW5nJ3Mgd3JvbmcuIEFzc3VtZSB3ZSBuZWVkIHRvIHJlbW91bnQuXHJcbiAgICAgIHNpZ25hdHVyZS5mb3JjZVJlc2V0ID0gdHJ1ZTtcclxuICAgICAgc2lnbmF0dXJlLmZ1bGxLZXkgPSBmdWxsS2V5O1xyXG4gICAgICByZXR1cm4gZnVsbEtleTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbmVzdGVkSG9va1NpZ25hdHVyZSA9IGFsbFNpZ25hdHVyZXNCeVR5cGUuZ2V0KGhvb2spO1xyXG5cclxuICAgIGlmIChuZXN0ZWRIb29rU2lnbmF0dXJlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgLy8gTm8gc2lnbmF0dXJlIG1lYW5zIEhvb2sgd2Fzbid0IGluIHRoZSBzb3VyY2UgY29kZSwgZS5nLiBpbiBhIGxpYnJhcnkuXHJcbiAgICAgIC8vIFdlJ2xsIHNraXAgaXQgYmVjYXVzZSB3ZSBjYW4gYXNzdW1lIGl0IHdvbid0IGNoYW5nZSBkdXJpbmcgdGhpcyBzZXNzaW9uLlxyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbmVzdGVkSG9va0tleSA9IGNvbXB1dGVGdWxsS2V5KG5lc3RlZEhvb2tTaWduYXR1cmUpO1xyXG5cclxuICAgIGlmIChuZXN0ZWRIb29rU2lnbmF0dXJlLmZvcmNlUmVzZXQpIHtcclxuICAgICAgc2lnbmF0dXJlLmZvcmNlUmVzZXQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bGxLZXkgKz0gJ1xcbi0tLVxcbicgKyBuZXN0ZWRIb29rS2V5O1xyXG4gIH1cclxuXHJcbiAgc2lnbmF0dXJlLmZ1bGxLZXkgPSBmdWxsS2V5O1xyXG4gIHJldHVybiBmdWxsS2V5O1xyXG59XHJcblxyXG5mdW5jdGlvbiBoYXZlRXF1YWxTaWduYXR1cmVzKHByZXZUeXBlLCBuZXh0VHlwZSkge1xyXG4gIHZhciBwcmV2U2lnbmF0dXJlID0gYWxsU2lnbmF0dXJlc0J5VHlwZS5nZXQocHJldlR5cGUpO1xyXG4gIHZhciBuZXh0U2lnbmF0dXJlID0gYWxsU2lnbmF0dXJlc0J5VHlwZS5nZXQobmV4dFR5cGUpO1xyXG5cclxuICBpZiAocHJldlNpZ25hdHVyZSA9PT0gdW5kZWZpbmVkICYmIG5leHRTaWduYXR1cmUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBpZiAocHJldlNpZ25hdHVyZSA9PT0gdW5kZWZpbmVkIHx8IG5leHRTaWduYXR1cmUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaWYgKGNvbXB1dGVGdWxsS2V5KHByZXZTaWduYXR1cmUpICE9PSBjb21wdXRlRnVsbEtleShuZXh0U2lnbmF0dXJlKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaWYgKG5leHRTaWduYXR1cmUuZm9yY2VSZXNldCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzUmVhY3RDbGFzcyh0eXBlKSB7XHJcbiAgcmV0dXJuIHR5cGUucHJvdG90eXBlICYmIHR5cGUucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhblByZXNlcnZlU3RhdGVCZXR3ZWVuKHByZXZUeXBlLCBuZXh0VHlwZSkge1xyXG4gIGlmIChpc1JlYWN0Q2xhc3MocHJldlR5cGUpIHx8IGlzUmVhY3RDbGFzcyhuZXh0VHlwZSkpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmIChoYXZlRXF1YWxTaWduYXR1cmVzKHByZXZUeXBlLCBuZXh0VHlwZSkpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXNvbHZlRmFtaWx5KHR5cGUpIHtcclxuICAvLyBPbmx5IGNoZWNrIHVwZGF0ZWQgdHlwZXMgdG8ga2VlcCBsb29rdXBzIGZhc3QuXHJcbiAgcmV0dXJuIHVwZGF0ZWRGYW1pbGllc0J5VHlwZS5nZXQodHlwZSk7XHJcbn0gLy8gSWYgd2UgZGlkbid0IGNhcmUgYWJvdXQgSUUxMSwgd2UgY291bGQgdXNlIG5ldyBNYXAvU2V0KGl0ZXJhYmxlKS5cclxuXHJcblxyXG5mdW5jdGlvbiBjbG9uZU1hcChtYXApIHtcclxuICB2YXIgY2xvbmUgPSBuZXcgTWFwKCk7XHJcbiAgbWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcclxuICAgIGNsb25lLnNldChrZXksIHZhbHVlKTtcclxuICB9KTtcclxuICByZXR1cm4gY2xvbmU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNsb25lU2V0KHNldCkge1xyXG4gIHZhciBjbG9uZSA9IG5ldyBTZXQoKTtcclxuICBzZXQuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIGNsb25lLmFkZCh2YWx1ZSk7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIGNsb25lO1xyXG59IC8vIFRoaXMgaXMgYSBzYWZldHkgbWVjaGFuaXNtIHRvIHByb3RlY3QgYWdhaW5zdCByb2d1ZSBnZXR0ZXJzIGFuZCBQcm94aWVzLlxyXG5cclxuXHJcbmZ1bmN0aW9uIGdldFByb3BlcnR5KG9iamVjdCwgcHJvcGVydHkpIHtcclxuICB0cnkge1xyXG4gICAgcmV0dXJuIG9iamVjdFtwcm9wZXJ0eV07XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAvLyBJbnRlbnRpb25hbGx5IGlnbm9yZS5cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBwZXJmb3JtUmVhY3RSZWZyZXNoKCkge1xyXG5cclxuICBpZiAocGVuZGluZ1VwZGF0ZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGlmIChpc1BlcmZvcm1pbmdSZWZyZXNoKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGlzUGVyZm9ybWluZ1JlZnJlc2ggPSB0cnVlO1xyXG5cclxuICB0cnkge1xyXG4gICAgdmFyIHN0YWxlRmFtaWxpZXMgPSBuZXcgU2V0KCk7XHJcbiAgICB2YXIgdXBkYXRlZEZhbWlsaWVzID0gbmV3IFNldCgpO1xyXG4gICAgdmFyIHVwZGF0ZXMgPSBwZW5kaW5nVXBkYXRlcztcclxuICAgIHBlbmRpbmdVcGRhdGVzID0gW107XHJcbiAgICB1cGRhdGVzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcclxuICAgICAgdmFyIGZhbWlseSA9IF9yZWZbMF0sXHJcbiAgICAgICAgICBuZXh0VHlwZSA9IF9yZWZbMV07XHJcbiAgICAgIC8vIE5vdyB0aGF0IHdlIGdvdCBhIHJlYWwgZWRpdCwgd2UgY2FuIGNyZWF0ZSBhc3NvY2lhdGlvbnNcclxuICAgICAgLy8gdGhhdCB3aWxsIGJlIHJlYWQgYnkgdGhlIFJlYWN0IHJlY29uY2lsZXIuXHJcbiAgICAgIHZhciBwcmV2VHlwZSA9IGZhbWlseS5jdXJyZW50O1xyXG4gICAgICB1cGRhdGVkRmFtaWxpZXNCeVR5cGUuc2V0KHByZXZUeXBlLCBmYW1pbHkpO1xyXG4gICAgICB1cGRhdGVkRmFtaWxpZXNCeVR5cGUuc2V0KG5leHRUeXBlLCBmYW1pbHkpO1xyXG4gICAgICBmYW1pbHkuY3VycmVudCA9IG5leHRUeXBlOyAvLyBEZXRlcm1pbmUgd2hldGhlciB0aGlzIHNob3VsZCBiZSBhIHJlLXJlbmRlciBvciBhIHJlLW1vdW50LlxyXG5cclxuICAgICAgaWYgKGNhblByZXNlcnZlU3RhdGVCZXR3ZWVuKHByZXZUeXBlLCBuZXh0VHlwZSkpIHtcclxuICAgICAgICB1cGRhdGVkRmFtaWxpZXMuYWRkKGZhbWlseSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3RhbGVGYW1pbGllcy5hZGQoZmFtaWx5KTtcclxuICAgICAgfVxyXG4gICAgfSk7IC8vIFRPRE86IHJlbmFtZSB0aGVzZSBmaWVsZHMgdG8gc29tZXRoaW5nIG1vcmUgbWVhbmluZ2Z1bC5cclxuXHJcbiAgICB2YXIgdXBkYXRlID0ge1xyXG4gICAgICB1cGRhdGVkRmFtaWxpZXM6IHVwZGF0ZWRGYW1pbGllcyxcclxuICAgICAgLy8gRmFtaWxpZXMgdGhhdCB3aWxsIHJlLXJlbmRlciBwcmVzZXJ2aW5nIHN0YXRlXHJcbiAgICAgIHN0YWxlRmFtaWxpZXM6IHN0YWxlRmFtaWxpZXMgLy8gRmFtaWxpZXMgdGhhdCB3aWxsIGJlIHJlbW91bnRlZFxyXG5cclxuICAgIH07XHJcbiAgICBoZWxwZXJzQnlSZW5kZXJlcklELmZvckVhY2goZnVuY3Rpb24gKGhlbHBlcnMpIHtcclxuICAgICAgLy8gRXZlbiBpZiB0aGVyZSBhcmUgbm8gcm9vdHMsIHNldCB0aGUgaGFuZGxlciBvbiBmaXJzdCB1cGRhdGUuXHJcbiAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0IGlmICpuZXcqIHJvb3RzIGFyZSBtb3VudGVkLCB0aGV5J2xsIHVzZSB0aGUgcmVzb2x2ZSBoYW5kbGVyLlxyXG4gICAgICBoZWxwZXJzLnNldFJlZnJlc2hIYW5kbGVyKHJlc29sdmVGYW1pbHkpO1xyXG4gICAgfSk7XHJcbiAgICB2YXIgZGlkRXJyb3IgPSBmYWxzZTtcclxuICAgIHZhciBmaXJzdEVycm9yID0gbnVsbDsgLy8gV2Ugc25hcHNob3QgbWFwcyBhbmQgc2V0cyB0aGF0IGFyZSBtdXRhdGVkIGR1cmluZyBjb21taXRzLlxyXG4gICAgLy8gSWYgd2UgZG9uJ3QgZG8gdGhpcywgdGhlcmUgaXMgYSByaXNrIHRoZXkgd2lsbCBiZSBtdXRhdGVkIHdoaWxlXHJcbiAgICAvLyB3ZSBpdGVyYXRlIG92ZXIgdGhlbS4gRm9yIGV4YW1wbGUsIHRyeWluZyB0byByZWNvdmVyIGEgZmFpbGVkIHJvb3RcclxuICAgIC8vIG1heSBjYXVzZSBhbm90aGVyIHJvb3QgdG8gYmUgYWRkZWQgdG8gdGhlIGZhaWxlZCBsaXN0IC0tIGFuIGluZmluaXRlIGxvb3AuXHJcblxyXG4gICAgdmFyIGZhaWxlZFJvb3RzU25hcHNob3QgPSBjbG9uZVNldChmYWlsZWRSb290cyk7XHJcbiAgICB2YXIgbW91bnRlZFJvb3RzU25hcHNob3QgPSBjbG9uZVNldChtb3VudGVkUm9vdHMpO1xyXG4gICAgdmFyIGhlbHBlcnNCeVJvb3RTbmFwc2hvdCA9IGNsb25lTWFwKGhlbHBlcnNCeVJvb3QpO1xyXG4gICAgZmFpbGVkUm9vdHNTbmFwc2hvdC5mb3JFYWNoKGZ1bmN0aW9uIChyb290KSB7XHJcbiAgICAgIHZhciBoZWxwZXJzID0gaGVscGVyc0J5Um9vdFNuYXBzaG90LmdldChyb290KTtcclxuXHJcbiAgICAgIGlmIChoZWxwZXJzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGhlbHBlcnMgZm9yIGEgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdCBSZWZyZXNoLicpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWZhaWxlZFJvb3RzLmhhcyhyb290KSkgey8vIE5vIGxvbmdlciBmYWlsZWQuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChyb290RWxlbWVudHMgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghcm9vdEVsZW1lbnRzLmhhcyhyb290KSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGVsZW1lbnQgPSByb290RWxlbWVudHMuZ2V0KHJvb3QpO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBoZWxwZXJzLnNjaGVkdWxlUm9vdChyb290LCBlbGVtZW50KTtcclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgaWYgKCFkaWRFcnJvcikge1xyXG4gICAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xyXG4gICAgICAgICAgZmlyc3RFcnJvciA9IGVycjtcclxuICAgICAgICB9IC8vIEtlZXAgdHJ5aW5nIG90aGVyIHJvb3RzLlxyXG5cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBtb3VudGVkUm9vdHNTbmFwc2hvdC5mb3JFYWNoKGZ1bmN0aW9uIChyb290KSB7XHJcbiAgICAgIHZhciBoZWxwZXJzID0gaGVscGVyc0J5Um9vdFNuYXBzaG90LmdldChyb290KTtcclxuXHJcbiAgICAgIGlmIChoZWxwZXJzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGhlbHBlcnMgZm9yIGEgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdCBSZWZyZXNoLicpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIW1vdW50ZWRSb290cy5oYXMocm9vdCkpIHsvLyBObyBsb25nZXIgbW91bnRlZC5cclxuICAgICAgfVxyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBoZWxwZXJzLnNjaGVkdWxlUmVmcmVzaChyb290LCB1cGRhdGUpO1xyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBpZiAoIWRpZEVycm9yKSB7XHJcbiAgICAgICAgICBkaWRFcnJvciA9IHRydWU7XHJcbiAgICAgICAgICBmaXJzdEVycm9yID0gZXJyO1xyXG4gICAgICAgIH0gLy8gS2VlcCB0cnlpbmcgb3RoZXIgcm9vdHMuXHJcblxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoZGlkRXJyb3IpIHtcclxuICAgICAgdGhyb3cgZmlyc3RFcnJvcjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdXBkYXRlO1xyXG4gIH0gZmluYWxseSB7XHJcbiAgICBpc1BlcmZvcm1pbmdSZWZyZXNoID0gZmFsc2U7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyKHR5cGUsIGlkKSB7XHJcbiAge1xyXG4gICAgaWYgKHR5cGUgPT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdHlwZSAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfSAvLyBUaGlzIGNhbiBoYXBwZW4gaW4gYW4gZWRnZSBjYXNlLCBlLmcuIGlmIHdlIHJlZ2lzdGVyXHJcbiAgICAvLyByZXR1cm4gdmFsdWUgb2YgYSBIT0MgYnV0IGl0IHJldHVybnMgYSBjYWNoZWQgY29tcG9uZW50LlxyXG4gICAgLy8gSWdub3JlIGFueXRoaW5nIGJ1dCB0aGUgZmlyc3QgcmVnaXN0cmF0aW9uIGZvciBlYWNoIHR5cGUuXHJcblxyXG5cclxuICAgIGlmIChhbGxGYW1pbGllc0J5VHlwZS5oYXModHlwZSkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfSAvLyBDcmVhdGUgZmFtaWx5IG9yIHJlbWVtYmVyIHRvIHVwZGF0ZSBpdC5cclxuICAgIC8vIE5vbmUgb2YgdGhpcyBib29ra2VlcGluZyBhZmZlY3RzIHJlY29uY2lsaWF0aW9uXHJcbiAgICAvLyB1bnRpbCB0aGUgZmlyc3QgcGVyZm9ybVJlYWN0UmVmcmVzaCgpIGNhbGwgYWJvdmUuXHJcblxyXG5cclxuICAgIHZhciBmYW1pbHkgPSBhbGxGYW1pbGllc0J5SUQuZ2V0KGlkKTtcclxuXHJcbiAgICBpZiAoZmFtaWx5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgZmFtaWx5ID0ge1xyXG4gICAgICAgIGN1cnJlbnQ6IHR5cGVcclxuICAgICAgfTtcclxuICAgICAgYWxsRmFtaWxpZXNCeUlELnNldChpZCwgZmFtaWx5KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBlbmRpbmdVcGRhdGVzLnB1c2goW2ZhbWlseSwgdHlwZV0pO1xyXG4gICAgfVxyXG5cclxuICAgIGFsbEZhbWlsaWVzQnlUeXBlLnNldCh0eXBlLCBmYW1pbHkpOyAvLyBWaXNpdCBpbm5lciB0eXBlcyBiZWNhdXNlIHdlIG1pZ2h0IG5vdCBoYXZlIHJlZ2lzdGVyZWQgdGhlbS5cclxuXHJcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcclxuICAgICAgc3dpdGNoIChnZXRQcm9wZXJ0eSh0eXBlLCAnJCR0eXBlb2YnKSkge1xyXG4gICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcclxuICAgICAgICAgIHJlZ2lzdGVyKHR5cGUucmVuZGVyLCBpZCArICckcmVuZGVyJyk7XHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XHJcbiAgICAgICAgICByZWdpc3Rlcih0eXBlLnR5cGUsIGlkICsgJyR0eXBlJyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBzZXRTaWduYXR1cmUodHlwZSwga2V5KSB7XHJcbiAgdmFyIGZvcmNlUmVzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xyXG4gIHZhciBnZXRDdXN0b21Ib29rcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xyXG5cclxuICB7XHJcbiAgICBpZiAoIWFsbFNpZ25hdHVyZXNCeVR5cGUuaGFzKHR5cGUpKSB7XHJcbiAgICAgIGFsbFNpZ25hdHVyZXNCeVR5cGUuc2V0KHR5cGUsIHtcclxuICAgICAgICBmb3JjZVJlc2V0OiBmb3JjZVJlc2V0LFxyXG4gICAgICAgIG93bktleToga2V5LFxyXG4gICAgICAgIGZ1bGxLZXk6IG51bGwsXHJcbiAgICAgICAgZ2V0Q3VzdG9tSG9va3M6IGdldEN1c3RvbUhvb2tzIHx8IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSAvLyBWaXNpdCBpbm5lciB0eXBlcyBiZWNhdXNlIHdlIG1pZ2h0IG5vdCBoYXZlIHNpZ25lZCB0aGVtLlxyXG5cclxuXHJcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcclxuICAgICAgc3dpdGNoIChnZXRQcm9wZXJ0eSh0eXBlLCAnJCR0eXBlb2YnKSkge1xyXG4gICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcclxuICAgICAgICAgIHNldFNpZ25hdHVyZSh0eXBlLnJlbmRlciwga2V5LCBmb3JjZVJlc2V0LCBnZXRDdXN0b21Ib29rcyk7XHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XHJcbiAgICAgICAgICBzZXRTaWduYXR1cmUodHlwZS50eXBlLCBrZXksIGZvcmNlUmVzZXQsIGdldEN1c3RvbUhvb2tzKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59IC8vIFRoaXMgaXMgbGF6aWx5IGNhbGxlZCBkdXJpbmcgZmlyc3QgcmVuZGVyIGZvciBhIHR5cGUuXHJcbi8vIEl0IGNhcHR1cmVzIEhvb2sgbGlzdCBhdCB0aGF0IHRpbWUgc28gaW5saW5lIHJlcXVpcmVzIGRvbid0IGJyZWFrIGNvbXBhcmlzb25zLlxyXG5cclxuZnVuY3Rpb24gY29sbGVjdEN1c3RvbUhvb2tzRm9yU2lnbmF0dXJlKHR5cGUpIHtcclxuICB7XHJcbiAgICB2YXIgc2lnbmF0dXJlID0gYWxsU2lnbmF0dXJlc0J5VHlwZS5nZXQodHlwZSk7XHJcblxyXG4gICAgaWYgKHNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGNvbXB1dGVGdWxsS2V5KHNpZ25hdHVyZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldEZhbWlseUJ5SUQoaWQpIHtcclxuICB7XHJcbiAgICByZXR1cm4gYWxsRmFtaWxpZXNCeUlELmdldChpZCk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldEZhbWlseUJ5VHlwZSh0eXBlKSB7XHJcbiAge1xyXG4gICAgcmV0dXJuIGFsbEZhbWlsaWVzQnlUeXBlLmdldCh0eXBlKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZmluZEFmZmVjdGVkSG9zdEluc3RhbmNlcyhmYW1pbGllcykge1xyXG4gIHtcclxuICAgIHZhciBhZmZlY3RlZEluc3RhbmNlcyA9IG5ldyBTZXQoKTtcclxuICAgIG1vdW50ZWRSb290cy5mb3JFYWNoKGZ1bmN0aW9uIChyb290KSB7XHJcbiAgICAgIHZhciBoZWxwZXJzID0gaGVscGVyc0J5Um9vdC5nZXQocm9vdCk7XHJcblxyXG4gICAgICBpZiAoaGVscGVycyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBoZWxwZXJzIGZvciBhIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QgUmVmcmVzaC4nKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGluc3RhbmNlc0ZvclJvb3QgPSBoZWxwZXJzLmZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaChyb290LCBmYW1pbGllcyk7XHJcbiAgICAgIGluc3RhbmNlc0ZvclJvb3QuZm9yRWFjaChmdW5jdGlvbiAoaW5zdCkge1xyXG4gICAgICAgIGFmZmVjdGVkSW5zdGFuY2VzLmFkZChpbnN0KTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBhZmZlY3RlZEluc3RhbmNlcztcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gaW5qZWN0SW50b0dsb2JhbEhvb2soZ2xvYmFsT2JqZWN0KSB7XHJcbiAge1xyXG4gICAgLy8gRm9yIFJlYWN0IE5hdGl2ZSwgdGhlIGdsb2JhbCBob29rIHdpbGwgYmUgc2V0IHVwIGJ5IHJlcXVpcmUoJ3JlYWN0LWRldnRvb2xzLWNvcmUnKS5cclxuICAgIC8vIFRoYXQgY29kZSB3aWxsIHJ1biBiZWZvcmUgdXMuIFNvIHdlIG5lZWQgdG8gbW9ua2V5cGF0Y2ggZnVuY3Rpb25zIG9uIGV4aXN0aW5nIGhvb2suXHJcbiAgICAvLyBGb3IgUmVhY3QgV2ViLCB0aGUgZ2xvYmFsIGhvb2sgd2lsbCBiZSBzZXQgdXAgYnkgdGhlIGV4dGVuc2lvbi5cclxuICAgIC8vIFRoaXMgd2lsbCBhbHNvIHJ1biBiZWZvcmUgdXMuXHJcbiAgICB2YXIgaG9vayA9IGdsb2JhbE9iamVjdC5fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XHJcblxyXG4gICAgaWYgKGhvb2sgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAvLyBIb3dldmVyLCBpZiB0aGVyZSBpcyBubyBEZXZUb29scyBleHRlbnNpb24sIHdlJ2xsIG5lZWQgdG8gc2V0IHVwIHRoZSBnbG9iYWwgaG9vayBvdXJzZWx2ZXMuXHJcbiAgICAgIC8vIE5vdGUgdGhhdCBpbiB0aGlzIGNhc2UgaXQncyBpbXBvcnRhbnQgdGhhdCByZW5kZXJlciBjb2RlIHJ1bnMgKmFmdGVyKiB0aGlzIG1ldGhvZCBjYWxsLlxyXG4gICAgICAvLyBPdGhlcndpc2UsIHRoZSByZW5kZXJlciB3aWxsIHRoaW5rIHRoYXQgdGhlcmUgaXMgbm8gZ2xvYmFsIGhvb2ssIGFuZCB3b24ndCBkbyB0aGUgaW5qZWN0aW9uLlxyXG4gICAgICB2YXIgbmV4dElEID0gMDtcclxuICAgICAgZ2xvYmFsT2JqZWN0Ll9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9IGhvb2sgPSB7XHJcbiAgICAgICAgcmVuZGVyZXJzOiBuZXcgTWFwKCksXHJcbiAgICAgICAgc3VwcG9ydHNGaWJlcjogdHJ1ZSxcclxuICAgICAgICBpbmplY3Q6IGZ1bmN0aW9uIChpbmplY3RlZCkge1xyXG4gICAgICAgICAgcmV0dXJuIG5leHRJRCsrO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25TY2hlZHVsZUZpYmVyUm9vdDogZnVuY3Rpb24gKGlkLCByb290LCBjaGlsZHJlbikge30sXHJcbiAgICAgICAgb25Db21taXRGaWJlclJvb3Q6IGZ1bmN0aW9uIChpZCwgcm9vdCwgbWF5YmVQcmlvcml0eUxldmVsLCBkaWRFcnJvcikge30sXHJcbiAgICAgICAgb25Db21taXRGaWJlclVubW91bnQ6IGZ1bmN0aW9uICgpIHt9XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGhvb2suaXNEaXNhYmxlZCkge1xyXG4gICAgICAvLyBUaGlzIGlzbid0IGEgcmVhbCBwcm9wZXJ0eSBvbiB0aGUgaG9vaywgYnV0IGl0IGNhbiBiZSBzZXQgdG8gb3B0IG91dFxyXG4gICAgICAvLyBvZiBEZXZUb29scyBpbnRlZ3JhdGlvbiBhbmQgYXNzb2NpYXRlZCB3YXJuaW5ncyBhbmQgbG9ncy5cclxuICAgICAgLy8gVXNpbmcgY29uc29sZVsnd2FybiddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcclxuICAgICAgY29uc29sZVsnd2FybiddKCdTb21ldGhpbmcgaGFzIHNoaW1tZWQgdGhlIFJlYWN0IERldlRvb2xzIGdsb2JhbCBob29rIChfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pLiAnICsgJ0Zhc3QgUmVmcmVzaCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoaXMgc2hpbSBhbmQgd2lsbCBiZSBkaXNhYmxlZC4nKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfSAvLyBIZXJlLCB3ZSBqdXN0IHdhbnQgdG8gZ2V0IGEgcmVmZXJlbmNlIHRvIHNjaGVkdWxlUmVmcmVzaC5cclxuXHJcblxyXG4gICAgdmFyIG9sZEluamVjdCA9IGhvb2suaW5qZWN0O1xyXG5cclxuICAgIGhvb2suaW5qZWN0ID0gZnVuY3Rpb24gKGluamVjdGVkKSB7XHJcbiAgICAgIHZhciBpZCA9IG9sZEluamVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBpbmplY3RlZC5zY2hlZHVsZVJlZnJlc2ggPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluamVjdGVkLnNldFJlZnJlc2hIYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgLy8gVGhpcyB2ZXJzaW9uIHN1cHBvcnRzIFJlYWN0IFJlZnJlc2guXHJcbiAgICAgICAgaGVscGVyc0J5UmVuZGVyZXJJRC5zZXQoaWQsIGluamVjdGVkKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGlkO1xyXG4gICAgfTsgLy8gRG8gdGhlIHNhbWUgZm9yIGFueSBhbHJlYWR5IGluamVjdGVkIHJvb3RzLlxyXG4gICAgLy8gVGhpcyBpcyB1c2VmdWwgaWYgUmVhY3RET00gaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZC5cclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTc2MjZcclxuXHJcblxyXG4gICAgaG9vay5yZW5kZXJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaW5qZWN0ZWQsIGlkKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgaW5qZWN0ZWQuc2NoZWR1bGVSZWZyZXNoID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbmplY3RlZC5zZXRSZWZyZXNoSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIC8vIFRoaXMgdmVyc2lvbiBzdXBwb3J0cyBSZWFjdCBSZWZyZXNoLlxyXG4gICAgICAgIGhlbHBlcnNCeVJlbmRlcmVySUQuc2V0KGlkLCBpbmplY3RlZCk7XHJcbiAgICAgIH1cclxuICAgIH0pOyAvLyBXZSBhbHNvIHdhbnQgdG8gdHJhY2sgY3VycmVudGx5IG1vdW50ZWQgcm9vdHMuXHJcblxyXG4gICAgdmFyIG9sZE9uQ29tbWl0RmliZXJSb290ID0gaG9vay5vbkNvbW1pdEZpYmVyUm9vdDtcclxuXHJcbiAgICB2YXIgb2xkT25TY2hlZHVsZUZpYmVyUm9vdCA9IGhvb2sub25TY2hlZHVsZUZpYmVyUm9vdCB8fCBmdW5jdGlvbiAoKSB7fTtcclxuXHJcbiAgICBob29rLm9uU2NoZWR1bGVGaWJlclJvb3QgPSBmdW5jdGlvbiAoaWQsIHJvb3QsIGNoaWxkcmVuKSB7XHJcbiAgICAgIGlmICghaXNQZXJmb3JtaW5nUmVmcmVzaCkge1xyXG4gICAgICAgIC8vIElmIGl0IHdhcyBpbnRlbnRpb25hbGx5IHNjaGVkdWxlZCwgZG9uJ3QgYXR0ZW1wdCB0byByZXN0b3JlLlxyXG4gICAgICAgIC8vIFRoaXMgaW5jbHVkZXMgaW50ZW50aW9uYWxseSBzY2hlZHVsZWQgdW5tb3VudHMuXHJcbiAgICAgICAgZmFpbGVkUm9vdHMuZGVsZXRlKHJvb3QpO1xyXG5cclxuICAgICAgICBpZiAocm9vdEVsZW1lbnRzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICByb290RWxlbWVudHMuc2V0KHJvb3QsIGNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBvbGRPblNjaGVkdWxlRmliZXJSb290LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGhvb2sub25Db21taXRGaWJlclJvb3QgPSBmdW5jdGlvbiAoaWQsIHJvb3QsIG1heWJlUHJpb3JpdHlMZXZlbCwgZGlkRXJyb3IpIHtcclxuICAgICAgdmFyIGhlbHBlcnMgPSBoZWxwZXJzQnlSZW5kZXJlcklELmdldChpZCk7XHJcblxyXG4gICAgICBpZiAoaGVscGVycyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaGVscGVyc0J5Um9vdC5zZXQocm9vdCwgaGVscGVycyk7XHJcbiAgICAgICAgdmFyIGN1cnJlbnQgPSByb290LmN1cnJlbnQ7XHJcbiAgICAgICAgdmFyIGFsdGVybmF0ZSA9IGN1cnJlbnQuYWx0ZXJuYXRlOyAvLyBXZSBuZWVkIHRvIGRldGVybWluZSB3aGV0aGVyIHRoaXMgcm9vdCBoYXMganVzdCAodW4pbW91bnRlZC5cclxuICAgICAgICAvLyBUaGlzIGxvZ2ljIGlzIGNvcHktcGFzdGVkIGZyb20gc2ltaWxhciBsb2dpYyBpbiB0aGUgRGV2VG9vbHMgYmFja2VuZC5cclxuICAgICAgICAvLyBJZiB0aGlzIGJyZWFrcyB3aXRoIHNvbWUgcmVmYWN0b3JpbmcsIHlvdSdsbCB3YW50IHRvIHVwZGF0ZSBEZXZUb29scyB0b28uXHJcblxyXG4gICAgICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcclxuICAgICAgICAgIHZhciB3YXNNb3VudGVkID0gYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUgIT0gbnVsbCAmJiBhbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZS5lbGVtZW50ICE9IG51bGwgJiYgbW91bnRlZFJvb3RzLmhhcyhyb290KTtcclxuICAgICAgICAgIHZhciBpc01vdW50ZWQgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgIT0gbnVsbCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUuZWxlbWVudCAhPSBudWxsO1xyXG5cclxuICAgICAgICAgIGlmICghd2FzTW91bnRlZCAmJiBpc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgLy8gTW91bnQgYSBuZXcgcm9vdC5cclxuICAgICAgICAgICAgbW91bnRlZFJvb3RzLmFkZChyb290KTtcclxuICAgICAgICAgICAgZmFpbGVkUm9vdHMuZGVsZXRlKHJvb3QpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh3YXNNb3VudGVkICYmIGlzTW91bnRlZCkgOyBlbHNlIGlmICh3YXNNb3VudGVkICYmICFpc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgLy8gVW5tb3VudCBhbiBleGlzdGluZyByb290LlxyXG4gICAgICAgICAgICBtb3VudGVkUm9vdHMuZGVsZXRlKHJvb3QpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRpZEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgLy8gV2UnbGwgcmVtb3VudCBpdCBvbiBmdXR1cmUgZWRpdHMuXHJcbiAgICAgICAgICAgICAgZmFpbGVkUm9vdHMuYWRkKHJvb3QpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGhlbHBlcnNCeVJvb3QuZGVsZXRlKHJvb3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKCF3YXNNb3VudGVkICYmICFpc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgaWYgKGRpZEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgLy8gV2UnbGwgcmVtb3VudCBpdCBvbiBmdXR1cmUgZWRpdHMuXHJcbiAgICAgICAgICAgICAgZmFpbGVkUm9vdHMuYWRkKHJvb3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIE1vdW50IGEgbmV3IHJvb3QuXHJcbiAgICAgICAgICBtb3VudGVkUm9vdHMuYWRkKHJvb3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSAvLyBBbHdheXMgY2FsbCB0aGUgZGVjb3JhdGVkIERldlRvb2xzIGhvb2suXHJcblxyXG5cclxuICAgICAgcmV0dXJuIG9sZE9uQ29tbWl0RmliZXJSb290LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBoYXNVbnJlY292ZXJhYmxlRXJyb3JzKCkge1xyXG4gIC8vIFRPRE86IGRlbGV0ZSB0aGlzIGFmdGVyIHJlbW92aW5nIGRlcGVuZGVuY3kgaW4gUk4uXHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59IC8vIEV4cG9zZWQgZm9yIHRlc3RpbmcuXHJcblxyXG5mdW5jdGlvbiBfZ2V0TW91bnRlZFJvb3RDb3VudCgpIHtcclxuICB7XHJcbiAgICByZXR1cm4gbW91bnRlZFJvb3RzLnNpemU7XHJcbiAgfVxyXG59IC8vIFRoaXMgaXMgYSB3cmFwcGVyIG92ZXIgbW9yZSBwcmltaXRpdmUgZnVuY3Rpb25zIGZvciBzZXR0aW5nIHNpZ25hdHVyZS5cclxuLy8gU2lnbmF0dXJlcyBsZXQgdXMgZGVjaWRlIHdoZXRoZXIgdGhlIEhvb2sgb3JkZXIgaGFzIGNoYW5nZWQgb24gcmVmcmVzaC5cclxuLy9cclxuLy8gVGhpcyBmdW5jdGlvbiBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIGFzIGEgdHJhbnNmb3JtIHRhcmdldCwgZS5nLjpcclxuLy8gdmFyIF9zID0gY3JlYXRlU2lnbmF0dXJlRnVuY3Rpb25Gb3JUcmFuc2Zvcm0oKVxyXG4vL1xyXG4vLyBmdW5jdGlvbiBIZWxsbygpIHtcclxuLy8gICBjb25zdCBbZm9vLCBzZXRGb29dID0gdXNlU3RhdGUoMCk7XHJcbi8vICAgY29uc3QgdmFsdWUgPSB1c2VDdXN0b21Ib29rKCk7XHJcbi8vICAgX3MoKTsgLyogQ2FsbCB3aXRob3V0IGFyZ3VtZW50cyB0cmlnZ2VycyBjb2xsZWN0aW5nIHRoZSBjdXN0b20gSG9vayBsaXN0LlxyXG4vLyAgICAgICAgICAqIFRoaXMgZG9lc24ndCBoYXBwZW4gZHVyaW5nIHRoZSBtb2R1bGUgZXZhbHVhdGlvbiBiZWNhdXNlIHdlXHJcbi8vICAgICAgICAgICogZG9uJ3Qgd2FudCB0byBjaGFuZ2UgdGhlIG1vZHVsZSBvcmRlciB3aXRoIGlubGluZSByZXF1aXJlcy5cclxuLy8gICAgICAgICAgKiBOZXh0IGNhbGxzIGFyZSBub29wcy4gKi9cclxuLy8gICByZXR1cm4gPGgxPkhpPC9oMT47XHJcbi8vIH1cclxuLy9cclxuLy8gLyogQ2FsbCB3aXRoIGFyZ3VtZW50cyBhdHRhY2hlcyB0aGUgc2lnbmF0dXJlIHRvIHRoZSB0eXBlOiAqL1xyXG4vLyBfcyhcclxuLy8gICBIZWxsbyxcclxuLy8gICAndXNlU3RhdGV7W2Zvbywgc2V0Rm9vXX0oMCknLFxyXG4vLyAgICgpID0+IFt1c2VDdXN0b21Ib29rXSwgLyogTGF6eSB0byBhdm9pZCB0cmlnZ2VyaW5nIGlubGluZSByZXF1aXJlcyAqL1xyXG4vLyApO1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlU2lnbmF0dXJlRnVuY3Rpb25Gb3JUcmFuc2Zvcm0oKSB7XHJcbiAge1xyXG4gICAgdmFyIHNhdmVkVHlwZTtcclxuICAgIHZhciBoYXNDdXN0b21Ib29rcztcclxuICAgIHZhciBkaWRDb2xsZWN0SG9va3MgPSBmYWxzZTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodHlwZSwga2V5LCBmb3JjZVJlc2V0LCBnZXRDdXN0b21Ib29rcykge1xyXG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAvLyBXZSdyZSBpbiB0aGUgaW5pdGlhbCBwaGFzZSB0aGF0IGFzc29jaWF0ZXMgc2lnbmF0dXJlc1xyXG4gICAgICAgIC8vIHdpdGggdGhlIGZ1bmN0aW9ucy4gTm90ZSB0aGlzIG1heSBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXNcclxuICAgICAgICAvLyBpbiBIT0MgY2hhaW5zIGxpa2UgX3MoaG9jMShfcyhob2MyKF9zKGFjdHVhbEZ1bmN0aW9uKSkpKSkuXHJcbiAgICAgICAgaWYgKCFzYXZlZFR5cGUpIHtcclxuICAgICAgICAgIC8vIFdlJ3JlIGluIHRoZSBpbm5lcm1vc3QgY2FsbCwgc28gdGhpcyBpcyB0aGUgYWN0dWFsIHR5cGUuXHJcbiAgICAgICAgICBzYXZlZFR5cGUgPSB0eXBlO1xyXG4gICAgICAgICAgaGFzQ3VzdG9tSG9va3MgPSB0eXBlb2YgZ2V0Q3VzdG9tSG9va3MgPT09ICdmdW5jdGlvbic7XHJcbiAgICAgICAgfSAvLyBTZXQgdGhlIHNpZ25hdHVyZSBmb3IgYWxsIHR5cGVzIChldmVuIHdyYXBwZXJzISkgaW4gY2FzZVxyXG4gICAgICAgIC8vIHRoZXkgaGF2ZSBubyBzaWduYXR1cmVzIG9mIHRoZWlyIG93bi4gVGhpcyBpcyB0byBwcmV2ZW50XHJcbiAgICAgICAgLy8gcHJvYmxlbXMgbGlrZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIwNDE3LlxyXG5cclxuXHJcbiAgICAgICAgaWYgKHR5cGUgIT0gbnVsbCAmJiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSkge1xyXG4gICAgICAgICAgc2V0U2lnbmF0dXJlKHR5cGUsIGtleSwgZm9yY2VSZXNldCwgZ2V0Q3VzdG9tSG9va3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHR5cGU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gV2UncmUgaW4gdGhlIF9zKCkgY2FsbCB3aXRob3V0IGFyZ3VtZW50cywgd2hpY2ggbWVhbnNcclxuICAgICAgICAvLyB0aGlzIGlzIHRoZSB0aW1lIHRvIGNvbGxlY3QgY3VzdG9tIEhvb2sgc2lnbmF0dXJlcy5cclxuICAgICAgICAvLyBPbmx5IGRvIHRoaXMgb25jZS4gVGhpcyBwYXRoIGlzIGhvdCBhbmQgcnVucyAqaW5zaWRlKiBldmVyeSByZW5kZXIhXHJcbiAgICAgICAgaWYgKCFkaWRDb2xsZWN0SG9va3MgJiYgaGFzQ3VzdG9tSG9va3MpIHtcclxuICAgICAgICAgIGRpZENvbGxlY3RIb29rcyA9IHRydWU7XHJcbiAgICAgICAgICBjb2xsZWN0Q3VzdG9tSG9va3NGb3JTaWduYXR1cmUoc2F2ZWRUeXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzTGlrZWx5Q29tcG9uZW50VHlwZSh0eXBlKSB7XHJcbiAge1xyXG4gICAgc3dpdGNoICh0eXBlb2YgdHlwZSkge1xyXG4gICAgICBjYXNlICdmdW5jdGlvbic6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgLy8gRmlyc3QsIGRlYWwgd2l0aCBjbGFzc2VzLlxyXG4gICAgICAgICAgaWYgKHR5cGUucHJvdG90eXBlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGUucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAvLyBSZWFjdCBjbGFzcy5cclxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG93bk5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModHlwZS5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG93bk5hbWVzLmxlbmd0aCA+IDEgfHwgb3duTmFtZXNbMF0gIT09ICdjb25zdHJ1Y3RvcicpIHtcclxuICAgICAgICAgICAgICAvLyBUaGlzIGxvb2tzIGxpa2UgYSBjbGFzcy5cclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvXHJcblxyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGUucHJvdG90eXBlLl9fcHJvdG9fXyAhPT0gT2JqZWN0LnByb3RvdHlwZSkge1xyXG4gICAgICAgICAgICAgIC8vIEl0IGhhcyBhIHN1cGVyY2xhc3MuXHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9IC8vIFBhc3MgdGhyb3VnaC5cclxuICAgICAgICAgICAgLy8gVGhpcyBsb29rcyBsaWtlIGEgcmVndWxhciBmdW5jdGlvbiB3aXRoIGVtcHR5IHByb3RvdHlwZS5cclxuXHJcbiAgICAgICAgICB9IC8vIEZvciBwbGFpbiBmdW5jdGlvbnMgYW5kIGFycm93cywgdXNlIG5hbWUgYXMgYSBoZXVyaXN0aWMuXHJcblxyXG5cclxuICAgICAgICAgIHZhciBuYW1lID0gdHlwZS5uYW1lIHx8IHR5cGUuZGlzcGxheU5hbWU7XHJcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnICYmIC9eW0EtWl0vLnRlc3QobmFtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgY2FzZSAnb2JqZWN0JzpcclxuICAgICAgICB7XHJcbiAgICAgICAgICBpZiAodHlwZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZ2V0UHJvcGVydHkodHlwZSwgJyQkdHlwZW9mJykpIHtcclxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XHJcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XHJcbiAgICAgICAgICAgICAgICAvLyBEZWZpbml0ZWx5IFJlYWN0IGNvbXBvbmVudHMuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLl9nZXRNb3VudGVkUm9vdENvdW50ID0gX2dldE1vdW50ZWRSb290Q291bnQ7XHJcbmV4cG9ydHMuY29sbGVjdEN1c3RvbUhvb2tzRm9yU2lnbmF0dXJlID0gY29sbGVjdEN1c3RvbUhvb2tzRm9yU2lnbmF0dXJlO1xyXG5leHBvcnRzLmNyZWF0ZVNpZ25hdHVyZUZ1bmN0aW9uRm9yVHJhbnNmb3JtID0gY3JlYXRlU2lnbmF0dXJlRnVuY3Rpb25Gb3JUcmFuc2Zvcm07XHJcbmV4cG9ydHMuZmluZEFmZmVjdGVkSG9zdEluc3RhbmNlcyA9IGZpbmRBZmZlY3RlZEhvc3RJbnN0YW5jZXM7XHJcbmV4cG9ydHMuZ2V0RmFtaWx5QnlJRCA9IGdldEZhbWlseUJ5SUQ7XHJcbmV4cG9ydHMuZ2V0RmFtaWx5QnlUeXBlID0gZ2V0RmFtaWx5QnlUeXBlO1xyXG5leHBvcnRzLmhhc1VucmVjb3ZlcmFibGVFcnJvcnMgPSBoYXNVbnJlY292ZXJhYmxlRXJyb3JzO1xyXG5leHBvcnRzLmluamVjdEludG9HbG9iYWxIb29rID0gaW5qZWN0SW50b0dsb2JhbEhvb2s7XHJcbmV4cG9ydHMuaXNMaWtlbHlDb21wb25lbnRUeXBlID0gaXNMaWtlbHlDb21wb25lbnRUeXBlO1xyXG5leHBvcnRzLnBlcmZvcm1SZWFjdFJlZnJlc2ggPSBwZXJmb3JtUmVhY3RSZWZyZXNoO1xyXG5leHBvcnRzLnJlZ2lzdGVyID0gcmVnaXN0ZXI7XHJcbmV4cG9ydHMuc2V0U2lnbmF0dXJlID0gc2V0U2lnbmF0dXJlO1xyXG4gIH0pKCk7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/react-refresh/cjs/react-refresh-runtime.development.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/react-refresh/runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-refresh/runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\r\n\r\nif (false) {} else {\r\n  module.exports = __webpack_require__(/*! ./cjs/react-refresh-runtime.development.js */ \"./node_modules/next/dist/compiled/react-refresh/cjs/react-refresh-runtime.development.js\");\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LXJlZnJlc2gvcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLGtMQUFzRTtBQUN4RSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxyYXZpblxcRG9jdW1lbnRzXFxkZXZvcHMtc2hvd2Nhc2VcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXGNvbXBpbGVkXFxyZWFjdC1yZWZyZXNoXFxydW50aW1lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWZyZXNoLXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcclxufSBlbHNlIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LXJlZnJlc2gtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xyXG59XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/react-refresh/runtime.js\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ var __webpack_exports__ = (__webpack_exec__("./node_modules/next/dist/compiled/@next/react-refresh-utils/dist/runtime.js"));
/******/ _N_E = __webpack_exports__;
/******/ }
]);